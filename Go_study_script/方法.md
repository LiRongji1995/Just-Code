
# Go语言学习笔记 - 第五章 方法（完全版）

---

## ✅ 5.1 方法定义

### 什么是方法？
方法是**绑定到特定类型上的函数**，其语法为：

```go
func (r ReceiverType) MethodName(args...) returnType
```

它与普通函数的区别在于多了“接收者（receiver）”参数。

---

### 函数 vs 方法

| 区别点        | 函数（function）           | 方法（method）                   |
|---------------|----------------------------|----------------------------------|
| 是否绑定类型  | ❌ 否                       | ✅ 是，绑定到某个类型（struct 或自定义类型） |
| 定义语法      | `func Add(a int, b int)`   | `func (p Point) Move(dx, dy int)` |
| 接收者        | 无                         | 显式写在 func 后面的括号中         |
| 调用方式      | 直接调用                   | 必须由对象调用（如 `p.Move()`）     |

---

### 示例

```go
type Point struct {
    X, Y int
}

// 普通函数
func Add(a, b int) int {
    return a + b
}

// 方法
func (p Point) Move(dx, dy int) {
    p.X += dx // 注意：p 是值拷贝
}
```

---

## ✅ 5.2 值接收者 vs 指针接收者

```go
func (p Point) MoveByValue(dx, dy int) {
    p.X += dx
}

func (p *Point) MoveByPointer(dx, dy int) {
    p.X += dx
}
```

| 接收者类型     | 是否修改原对象 | 是否复制结构体 | 常用于               |
|----------------|----------------|----------------|----------------------|
| 值接收者       | ❌ 否           | ✅ 是           | 小型数据、只读场景     |
| 指针接收者     | ✅ 是           | ❌ 否           | 修改对象、大型结构体   |

🧠 Go 的方法接收者设计体现了“值语义优先 + 引用语义可选”。

---

## ✅ 5.3 方法集（Method Set）

### 定义：
方法集是一个类型拥有的方法集合。它**决定接口匹配和方法可见性**。

| 类型    | 方法集包含                     |
|---------|--------------------------------|
| `T`     | 所有 `func (t T)` 方法         |
| `*T`    | 所有 `func (t T)` 和 `func (t *T)` 方法 |

```go
type Cat struct{}
func (c *Cat) Meow() {}
func (c Cat) Sit()   {}

var c Cat
var pc *Cat = &c

// 方法集匹配接口
type Meower interface {
    Meow()
}

// var _ Meower = c   // ❌ 编译错误
var _ Meower = pc    // ✅ 指针类型方法集完整
```

---

## ✅ 5.4 方法提升（匿名字段模拟继承）

```go
type Animal struct{}
func (a Animal) Eat() {}

type Dog struct {
    Animal // 匿名字段
}

d := Dog{}
d.Eat() // ✅ 自动提升为 Dog 的方法
```

Go 不支持继承，但通过嵌入字段实现“方法继承”的效果。

---

## ✅ 5.5 方法表达式与方法值

### 方法表达式（不绑定对象）：

```go
type T struct{}
func (t T) Hello() {}

f := T.Hello
f(T{})  // 显式传对象
```

### 方法值（绑定对象）：

```go
t := T{}
f := t.Hello
f()     // 已绑定接收者，变为闭包
```

---

## ✅ 5.6 方法与接口匹配规则

### 接口实现依赖方法集：

```go
type Walker interface {
    Walk()
}

type Human struct{}
func (h *Human) Walk() {}

var h Human
var p *Human = &h

// var _ Walker = h   // ❌ 不满足接口
var _ Walker = p     // ✅ 满足接口
```

💡 指针接收者的方法，只能由指针类型满足接口。

---

## ✅ 5.7 为什么要区分值接收者和指针接收者？

| 理由                 | 说明 |
|----------------------|------|
| 支持值语义           | 保证小对象的轻量复制与只读操作 |
| 明确语义             | 接收者传值 or 引用，一目了然 |
| 控制副作用           | 值接收者方法不会修改原对象 |
| 提高性能与安全性     | 避免堆逃逸，避免共享并发问题 |

Go 倡导“清晰胜于智能”，所以不隐藏接收者行为，而是让你**显式选择**。

---

## ✅ 小结表格

| 特性                 | 值接收者       | 指针接收者     |
|----------------------|----------------|----------------|
| 是否修改原始对象     | 否             | 是             |
| 是否可由值调用       | ✅             | ✅（自动转换） |
| 是否可由指针调用     | ✅             | ✅             |
| 方法集包含在哪些类型 | `T`           | `*T`           |
| 推荐场景             | 小对象、只读   | 大对象、修改字段 |

---

## ✅ 口诀记忆

```
函数独立无接收，方法总随对象走；
指针方法值不配，方法集要记牢；
接口匹配靠方法，值改需指针调；
清晰胜魔法，Go 拒绝语义迷雾。
```

---
