# 🧠 Go Runtime / 编译器 / 内存模型：深入学习项目指南

> 如果目标是**深入 Go 内核、接近语言极限、成为 Go 大师**，这些项目可以强化你对 Go 的调度、内存管理、编译流程的理解。

---

## 📦 项目类型推荐及对应强化方向

### 1. 实现一个协程调度器（简化版 goroutine 调度）

**强化理解：**
- G/M/P 模型核心思想
- goroutine 切换的时机与成本
- 调度器如何避免饥饿 / 死锁

**可做项目：**
- 用 Go 写一个 lightweight 调度器（channel / select 模拟）
- 模拟 P 数量限制、任务窃取、异步唤醒机制

---

### 2. 开发一个自定义 GC 示例程序

**强化理解：**
- heap 对象分配策略
- 标记-清除、分代 GC 原理
- GC 对 latency 和吞吐影响

**可做项目：**
- 写一个大对象池管理模块，观察 GC 行为（`GODEBUG=gctrace=1`）
- 实现一个内存池（Pool）替代策略
- 对比 `-gcflags "-m"` 的逃逸分析结果与实际行为

---

### 3. 实现自己的编译阶段分析工具（AST → SSA）

**强化理解：**
- Go 编译流程（parser → types → SSA）
- SSA 中的值传播与优化
- 指令生成背后的逻辑

**可做项目：**
- 使用 `golang.org/x/tools/go/ssa` 编写静态分析工具
- 实现逃逸变量可视化工具
- 实现函数调用链分析器

---

### 4. 构造一组基准测试 + Trace 分析

**强化理解：**
- goroutine 数量对调度影响
- channel 阻塞/解阻塞的代价
- GC 对 latency 的实际影响

**可做项目：**
- 用 `pprof`、`runtime/trace`、`go test -bench` 做性能剖析
- 微基准测试：map 并发访问 vs. sync.Map
- 使用 `GODEBUG=schedtrace=1000` 查看调度细节

---

### 5. 深入阅读 Go runtime 源码 + 跟踪调度/GC 行为

**强化理解：**
- runtime 管理线程、协程、栈空间的方法
- defer/panic 的底层实现
- G/M/P 的调度过程

**可做项目：**
- 阅读 runtime 中的 `sched.go`、`mgc.go`、`panic.go`
- 修改源码打印调度/GC 日志，观察其触发时机

---

## 🧭 项目组合建议（阶段式）

| 阶段 | 项目                       | 主攻点               |
|------|----------------------------|----------------------|
| ✅ 入门 | goroutine 调度模拟器         | Runtime 调度机制      |
| ✅ 中级 | 自定义内存管理模块           | GC、逃逸分析         |
| ✅ 高阶 | SSA 静态分析器              | 编译器结构与优化       |
| ✅ 实战 | trace + bench + 源码 patch | 综合理解与调优能力     |

---
