# Go 闭包完整学习笔记

## 1. 闭包定义

> 闭包（Closure）是：**函数 + 其引用的自由变量**的组合。

一个闭包能“记住”它创建时作用域中的变量，即使外部函数已返回。

---

## 2. Go 中闭包示例

```go
func adder() func(int) int {
    sum := 0
    return func(x int) int {
        sum += x
        return sum
    }
}

a := adder()
fmt.Println(a(1)) // 1
fmt.Println(a(2)) // 3
```

该函数 `adder()` 返回一个“记住了 sum”的函数。调用 `a(x)` 会不断在这个私有的 `sum` 上加值。

---

## 3. 闭包的常见使用场景

| 场景       | 描述 |
|------------|------|
| 封装状态（计数器） | 使用闭包保存私有变量 |
| 函数工厂 | 根据传入参数生成定制函数 |
| 延迟执行 | defer 中使用闭包捕获执行状态 |
| 模拟私有字段 | 无 class 场景下封装状态 |
| 循环变量捕获陷阱 | 注意变量引用范围导致的并发 bug |

---

## 4. 为什么用闭包，而不是其他方式？

| 场景 | 替代方式 | 闭包优点 |
|------|----------|----------|
| 计数器 | 结构体 + 方法 | 闭包更轻量，不需显式类型 |
| 工厂函数 | 结构体封装 | 闭包表达意图更直接 |
| defer 延迟 | 函数/闭包 | 只有闭包能捕获局部状态 |
| 模拟私有变量 | 结构体导出控制 | 闭包天然封装作用域 |
| 循环变量 | 传参/复制变量 | 闭包需显式传参防止引用问题 |

---

## 5. 各语言对闭包的支持对比

| 语言   | 是否支持闭包 | 可否修改外部变量 | 用法备注 |
|--------|---------------|------------------|----------|
| Go     | ✅ 完整支持   | ✅ 可修改        | 用于函数工厂/状态封装 |
| Python | ✅ 完全支持   | ✅ `nonlocal`    | 用法自然 |
| Java   | ✅ 有限制支持 | ❌ 不可修改      | 只能读，变量必须 final 或 effectively final |
| C++    | ✅ 支持强     | ✅ 可引用捕获    | 支持灵活的捕获语法 |

---

## 6. 总结一句话

> 闭包是函数式编程中非常强大的工具，让函数“携带状态”成为可能。它提供一种优雅的方式来封装局部变量、隐藏实现细节、构造高阶函数。

