
# Go è¯­è¨€ reflect åå°„æœºåˆ¶ï¼šè¯¦è§£ + å®ä¾‹ + å®è·µæ„ä¹‰

---

## ğŸª 1. åŸºæœ¬æ¦‚å¿µ

Go çš„ reflect åŒ…å…è®¸ç¨‹åºåœ¨è¿è¡Œæ—¶åŠ¨æ€åœ°æ£€æŸ¥ã€ä¿®æ”¹å¯¹è±¡çš„ç±»å‹å’Œå€¼ï¼Œæ ¸å¿ƒç±»å‹åŒ…æ‹¬ï¼š

- `reflect.Type`: æè¿°ç±»å‹ä¿¡æ¯
- `reflect.Value`: æè¿°å€¼ä¿¡æ¯ï¼Œå¯ç”¨äºè·å–ã€ä¿®æ”¹å€¼

```go
var x int = 10
t := reflect.TypeOf(x)
v := reflect.ValueOf(x)
fmt.Println(t.Kind())     // int
fmt.Println(v.Int())      // 10
```

---

## ğŸ“¦ 2. struct tag ä¸æ¥å£ä¼ å‚è§£é‡Š

### struct tag

```go
type User struct {
    ID int `gorm:"column:id"`
}
```

è¿™é‡Œçš„ `gorm:"column:id"` æ˜¯ **struct tag**ï¼Œç”¨äºå­˜å‚¨å…ƒæ•°æ®ã€‚å¯ä»¥é€šè¿‡ï¼š

```go
field := reflect.TypeOf(User{}).Field(0)
fmt.Println(field.Tag.Get("gorm"))  // è¾“å‡º column:id
```

### interface{} ä¸ºä»€ä¹ˆå¯ä»¥æ¥æ”¶ä»»æ„ç»“æ„ä½“ï¼Ÿ

```go
func GenerateInsertSQL(v interface{}) string {}
```

è™½ç„¶å‚æ•°æ˜¯æ¥å£ç±»å‹ï¼Œä½† reflect å¯ä»¥è·å–ä¼ å…¥å‚æ•°çš„çœŸå®ç±»å‹ï¼š

```go
t := reflect.TypeOf(v)
if t.Kind() == reflect.Struct {
    // æ˜¯ç»“æ„ä½“ç±»å‹
}
```

æ‰€ä»¥å‡½æ•°è™½ç„¶æ¥å— `interface{}`ï¼Œ**å®è´¨æ˜¯å¯¹â€œä»»æ„ç»“æ„ä½“â€çš„æ³›åŒ–æ”¯æŒ**ã€‚

---

## ğŸ’¡ 3. ç¤ºä¾‹ä¸€ï¼šMini GORM ä¸­ reflect ç”¨æ³•ï¼ˆé€è¡Œè¯´æ˜ï¼‰

```go
type User struct {
    ID   int    `gorm:"column:id"`
    Name string `gorm:"column:name"`
    Age  int    `gorm:"column:age"`
}

func GenerateInsertSQL(v interface{}) string {
    t := reflect.TypeOf(v)     // è·å–ç±»å‹ä¿¡æ¯
    val := reflect.ValueOf(v)  // è·å–å€¼ä¿¡æ¯

    if t.Kind() != reflect.Struct {
        panic("Only struct is supported")
    }

    var columns, values []string
    for i := 0; i < t.NumField(); i++ {
        field := t.Field(i)
        tag := field.Tag.Get("gorm")
        if tag == "" { tag = field.Name }
        columns = append(columns, tag)

        fieldVal := val.Field(i)
        switch fieldVal.Kind() {
        case reflect.String:
            values = append(values, fmt.Sprintf("'%s'", fieldVal.String()))
        default:
            values = append(values, fmt.Sprintf("%v", fieldVal.Interface()))
        }
    }

    return fmt.Sprintf("INSERT INTO %s (%s) VALUES (%s);",
        strings.ToLower(t.Name()),
        strings.Join(columns, ", "),
        strings.Join(values, ", "))
}
```

ä½“ç° reflect çš„åœ°æ–¹ï¼š
- `reflect.TypeOf()` è·å–å­—æ®µæ•°é‡ä¸æ ‡ç­¾
- `reflect.ValueOf()` è·å–å­—æ®µå€¼
- ç»“æ„ä½“å­—æ®µä¿¡æ¯ä¸ tag çš„æå–ã€åŠ¨æ€æ‹¼æ¥ SQL

---

## ğŸš€ 4. ç¤ºä¾‹äºŒï¼šMini RPC æ¡†æ¶ä¸­ reflect ç”¨æ³•ï¼ˆé€è¡Œè¯´æ˜ï¼‰

```go
type RPCServer struct {
    methods map[string]reflect.Value
}

func (s *RPCServer) Register(name string, fn interface{}) {
    s.methods[name] = reflect.ValueOf(fn)  // å°†å‡½æ•°åŒ…è£…ä¸º reflect.Value
}

func (s *RPCServer) Call(name string, args ...interface{}) []interface{} {
    method := s.methods[name]               // å–å‡ºç›®æ ‡å‡½æ•°
    in := make([]reflect.Value, len(args))  // æ„é€ å‚æ•°
    for i, arg := range args {
        in[i] = reflect.ValueOf(arg)
    }
    out := method.Call(in)                  // æ‰§è¡Œå‡½æ•°
    result := make([]interface{}, len(out)) // å¤„ç†è¿”å›å€¼
    for i, val := range out {
        result[i] = val.Interface()
    }
    return result
}
```

ä½“ç° reflect çš„åœ°æ–¹ï¼š
- `reflect.ValueOf(fn)` åŠ¨æ€æ¥æ”¶ä»»æ„å‡½æ•°
- `.Call([]reflect.Value)` åŠ¨æ€è°ƒç”¨
- `.Interface()` è½¬å›æ™®é€šç±»å‹

---

## ğŸ¤” 5. æ—¥å¸¸å¼€å‘ä¸­ reflect çš„ä½¿ç”¨é¢‘ç‡åˆ†æ

### âœ… æ¡†æ¶ä½œè€…ä½¿ç”¨é¢‘ç¹ï¼š
- `encoding/json`
- `gorm`
- `gin` å‚æ•°ç»‘å®š
- `validator`, `protobuf`, `zap`

### âŒ æ™®é€šä¸šåŠ¡ä»£ç ä¸­ä¸»åŠ¨ä½¿ç”¨è¾ƒå°‘ï¼š
- è‡ªå·±æ‰‹å†™åå°„å®¹æ˜“å‡ºé”™ã€è¯­æ³•ç¹ç
- æ€§èƒ½å¼€é”€é«˜ï¼Œå¤±å»ç±»å‹å®‰å…¨
- æ¨èç”¨äºå·¥å…·ç±»ã€è°ƒè¯•å™¨ã€é€šç”¨å‹å‡½æ•°

---

## ğŸ§  æ€»ç»“ï¼šä»€ä¹ˆæ—¶å€™è¯¥ç”¨ reflectï¼Ÿ

| æ˜¯å¦ä½¿ç”¨ | å…¸å‹åœºæ™¯ |
|----------|----------|
| âœ… ä½¿ç”¨ | å†™æ¡†æ¶ã€ç¼–å†™é€šç”¨å·¥å…·ã€éœ€è¦åŠ¨æ€å¤„ç†ç±»å‹ |
| âŒ é¿å… | æ™®é€šä¸šåŠ¡é€»è¾‘ä¸­ï¼Œèƒ½é™æ€å†™å°±é™æ€å†™ |
| âš ï¸ æ…ç”¨ | æ€§èƒ½æ•æ„Ÿè·¯å¾„ã€é¢‘ç¹è°ƒç”¨é€»è¾‘ä¸­ |

---

å¦‚æœä½ å¸Œæœ›æˆ‘æŠŠè¿™äº›ç¤ºä¾‹è¿›ä¸€æ­¥å°è£…ä¸º package æˆ–æ·»åŠ æ³›å‹/ç±»å‹æ ¡éªŒæ”¯æŒï¼Œä¹Ÿå¯ä»¥ç»§ç»­æé—®ã€‚
