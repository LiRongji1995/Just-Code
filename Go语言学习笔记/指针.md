
# Go语言学习笔记 - 指针详解（基于第1.7节并补充）

---

## ✅ 一、基础知识

### 📌 指针的定义与使用

```go
var x int = 10
var p *int = &x // p 是指向 x 的指针
fmt.Println(*p) // 输出 x 的值：10
```

- 使用 `&` 取地址；
- 使用 `*` 解引用访问地址指向的值；
- Go 不支持指针运算（如 `p++`）；
- Go 不需要 `->`，可以直接用 `p.field` 访问结构体字段。

---

## ✅ 二、指针与结构体

```go
type data struct{ a int }

var d = data{1234}
p := &d

fmt.Println(p.a)      // ✅ 自动解引用访问字段
fmt.Println((*p).a)   // 也可以显式写法
```

---

## ✅ 三、指针的默认值和 nil

- 指针未初始化时默认值为 `nil`；
- `nil` 是 Go 中通用的“空引用”标志。

---

## ✅ 四、指针与函数传参

Go 所有参数传递都是值传递，但指针传参可间接修改原值：

```go
func update(x *int) {
    *x = 100
}
var n = 10
update(&n)
fmt.Println(n) // 100
```

---

## ✅ 五、指针作为复合类型成员

- Slice 本身是引用类型，传值即可共享底层数组；
- Map 不能直接取值地址（`&m[key]` 会报错）；
- Channel 是引用类型，通常无需指针包装。

---

## ✅ 六、指针逃逸分析

函数返回局部变量指针，Go 编译器会将其分配到堆上：

```go
func NewInt() *int {
    x := 100
    return &x // 会逃逸到堆上
}
```

可用命令查看：

```bash
go build -gcflags="-m"
```

---

## ✅ 七、unsafe.Pointer 与 uintptr（高级）

| 类型           | 特点                           |
|----------------|--------------------------------|
| `unsafe.Pointer` | 通用转换指针，类型无关         |
| `uintptr`        | 原始整数类型，GC 不追踪         |

```go
var p *int
up := uintptr(unsafe.Pointer(p))
p2 := (*int)(unsafe.Pointer(up)) // 允许逆转换
```

⚠️ 不要长时间使用 uintptr，否则指针会被 GC 回收！

---

## ✅ 八、指针哲学：何时该用指针？

| 类型             | 是否建议用指针 | 理由                     |
|------------------|----------------|--------------------------|
| 基本类型         | 可选           | 减少复制，修改原始值     |
| 结构体（小）     | 不建议         | 值语义，简洁无副作用     |
| 结构体（大）     | 建议           | 避免复制，传引用更快     |
| slice / map / chan | 不用指针     | 本身已是引用             |
| interface{}       | 本质封装引用   | 使用值即可               |

---

## ✅ 九、总结口诀

```
指针不可算，字段能直点；
slice 本就引，map 别乱改；
逃逸堆与栈，GC 看不见；
unsafe 用得妙，误用痛难当。
```

---

